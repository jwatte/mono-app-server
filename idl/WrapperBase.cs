
using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Net;
using System.Reflection;
using System.IO;

namespace IMVU.IDL
{
	public abstract class WrapperBase
	{
        static Counter wrapper_counter = new Counter("api.wrapper", "number of API wrappers installed");

		public WrapperBase(string name)
		{
			this.name = name;
            error_counter = new Counter("api." + this.name + ".error", "number of errors dispatching within API");
            permission_counter = new Counter("api." + this.name + ".error.permission", "number of permission errors in API invocation");
		}

		public abstract void Initialize();
		public abstract string Version();
		
		public string CodePath { get; set; }
		
		//	This function is called by the subclass to define the methods that are expected.
		//	The subclass glue is generated by the IDL compiler.
		protected void InstallMethods(IMVU.IDL.ApiMethod[] methods)
		{
			LoadImplementationClass();
			if (implementation == null)
			{
				throw new InvalidOperationException("Could not load API implementation assembly " + this.name + ".dll");
			}
			//	todo: inspect for methods
			foreach (ApiMethod am in methods)
			{
				Console.WriteLine("Verifying method {0}", am.name);
				MethodInfo mi = implementation.GetType().GetMethod(am.name);
				if (mi == null)
				{
					foreach (MethodInfo mi2 in implementation.GetType().GetMethods())
					{
						Console.WriteLine("{0}.{1}()", this.name, mi2.Name);
					}
					throw new InvalidOperationException("Class " + this.name + " method " + am.name + 
					                                    " does not exist!");
				}
				string err = null;
				if (!VerifyArgs(mi, am, out err))
				{
					throw new InvalidOperationException("Class " + this.name + " method " + am.name + 
					                                    " has bad args: " + err);
				}
				am.methodInfo = mi;
				this.methods.Add(am.name, am);
			}
            //  I'm good!
            wrapper_counter.Count();
		}
		
		void LoadImplementationClass()
		{
			Console.WriteLine("LoadImplementationClass(); CodePath = {0}", CodePath);
			string path = Path.Combine(Path.Combine(CodePath, "api"), "api." + name + ".dll");
			Assembly implAssy = Assembly.LoadFile(path);
			if (implAssy == null)
			{
				Console.WriteLine("assembly " + path + " not loadable");
				return;
			}
			implementation = implAssy.CreateInstance("api." + name);
			Console.WriteLine("created {0} from {1}", implementation.GetType().FullName, implAssy.FullName);
			if (implementation == null)
			{
				Console.WriteLine("could not create instance of type " + name + " from assembly " + path);
			}
		}

		//	Note: MethodInfo takes an additional hidden "ctx" argument
		bool VerifyArgs(MethodInfo mi, IMVU.IDL.ApiMethod am, out string err)
		{
			Console.WriteLine("VerifyArgs({0}, {1})", mi, am);
			err = "";
			if (mi == null)
			{
				err = "The method does not exist";
				return false;
			}
			if (mi.IsGenericMethod || mi.IsGenericMethodDefinition || !mi.IsPublic)
			{
				err = "The method must be non-generic and public";
				return false;
			}
			ParameterInfo[] pis = mi.GetParameters();
			if (pis == null || pis.Length == 0)
			{
				err = "The context argument is mandatory on method " + mi.Name + " of class " + mi.ReflectedType.Name;
				return false;
			}
			if (am.parameters == null || pis.Length != am.parameters.Length + 1)
			{
				int len = 0;
				if (am.parameters != null)
				{
					len = am.parameters.Length;
				}
				err = "The method has " + (pis.Length - 1).ToString() + " arguments, but " + len.ToString()
					+ " parameters are expected.";
				return false;
			}
			int ix = 0;
			foreach (ParameterInfo pi in pis)
			{
				if (ix == 0)
				{
					if (!pi.ParameterType.IsAssignableFrom(typeof(IContext)))
					{
						err = "The first argument to method " + mi.Name + " of type " + mi.ReflectedType.Name + 
							" must be of type IContext.";
						return false;
					}
				}
				else
				{
					if (!pi.ParameterType.IsAssignableFrom(am.parameters[ix-1].type.Type))
					{
						err = "The method argument " + am.parameters[ix-1].name + " takes type " +
							pi.ParameterType.Name + " but should take type " + am.parameters[ix-1].type.Name;
						return false;
					}
					if (pi.Name != am.parameters[ix-1].name)
					{
						Console.WriteLine("Warning: type " + this.name + " method " + am.name + " argument " +
						                  am.parameters[ix-1].name + " was renamed to " + mi.Name + " in implementation.");
					}
				}
				++ix;
			}
			return true;
		}

        Counter error_counter;
        Counter permission_counter;

        static Counter call_counter = new Counter("api.wrapper.call", "total number of wrapped API calls");

		public IMVU.IDL.Buffer CallMethodForUser(UserSession sess, string method, NameValueCollection p, IContext ictx)
		{
			ApiMethod am;
			if (!methods.TryGetValue(method, out am))
			{
                error_counter.Count();
				Services.Error(ictx, "no such method: {0}", method);
				return null;
			}
			if (!am.ValidateUser(sess))
			{
                permission_counter.Count();
				Services.Error(ictx, "permission denied for method: {0}", method);
				return null;
			}

            call_counter.Count();

			return am.Invoke(implementation, sess, p, ictx);
		}
		
		Dictionary<string, IMVU.IDL.ApiMethod> methods = new Dictionary<string, IMVU.IDL.ApiMethod>();
		public readonly string name;
		public object implementation;
	}
	
}
