
using System;
using System.Xml;
using IMVU.IDL;
using System.IO;
using System.Text.RegularExpressions;

namespace apimono
{
	class MainClass
	{
		static void usage()
		{
			Console.WriteLine("Usage: apimono input.xml [-idl[:%.idl.cs]] [-stub[:%.stub.cs]] [-entity[:%.entity.cs]]");
			System.Environment.Exit(-1);
		}
		
		static string GetPat(string[] a, string dflt)
		{
			if (a.Length != 2)
			{
				return dflt;
			}
			if (a[1].Length < 1)
			{
				Console.WriteLine("Pattern for {0} cannot be empty", a[0]);
				usage();
			}
			return a[1];
		}
		
		public static void Main (string[] args)
		{
			if (args.Length < 2 || args[0][0] == '-')
			{
				usage();
			}
			string inputfilename = null;
			string idlpat = null;
			string stubpat = null;
			string entitypat = null;
			foreach (string s in args)
			{
				if (inputfilename == null)
				{
					inputfilename = s;
				}
				else
				{
					string[] arg = s.Split(new char[] { ':' }, 2);
					if (arg[0] == "-idl")
					{
						if (idlpat != null)
						{
							Console.WriteLine("Can't specify IDL pattern twice");
							usage();
						}
						idlpat = GetPat(arg, "%.idl.cs");
					}
					else if (arg[0] == "-stub")
					{
						if (stubpat != null)
						{
							Console.WriteLine("Can't specify stub pattern twice");
							usage();
						}
						stubpat = GetPat(arg, "%.stub.cs");
					}
					else if (arg[0] == "-entity")
					{
						if (entitypat != null)
						{
							Console.WriteLine("Can't specify entity pattern twice");
							usage();
						}
						entitypat = GetPat(arg, "%.entity.cs");
					}
					else
					{
						Console.WriteLine("Unknown argument: {0}", s);
						usage();
					}
				}
			}
			try
			{
				XmlDocument xd = new XmlDocument();
				xd.Load(inputfilename);
				if (idlpat != null)
				{
					EmitInterfaces(xd.SelectNodes("/idl/interface"), idlpat);
				}
				if (stubpat != null)
				{
					EmitStubs(xd.SelectNodes("/idl/interface"), stubpat);
				}
				if (entitypat != null)
				{
					EmitEntities(xd.SelectNodes("/idl/entity"), entitypat);
				}
			}
			catch (System.Exception x)
			{
				Console.WriteLine("error: {0}", x.Message);
				usage();
			}
		}
		
		static Regex idre = new Regex("^[_a-z][_a-z0-9]*$", RegexOptions.IgnoreCase | RegexOptions.Compiled);
		
		static void EmitInterfaces(XmlNodeList xnl, string pat)
		{
			foreach (XmlNode xn in xnl)
			{
				XmlAttribute xa = xn.Attributes["name"];
				if (xa == null || xa.Value == "")
				{
					throw new InvalidDataException("interface elements must have a name attribute");
				}
				if (!idre.IsMatch(xa.Value))
				{
					throw new InvalidDataException("interface name " + xa.Value + " is not a proper identifier");
				}
				MemoryStream idls = new MemoryStream();
				MemoryStream stubs = new MemoryStream();
				EmitInterface(xn, new StreamWriter(idls), new StreamWriter(stubs));
				string path = pat.Replace("%", xa.Value);
				using (FileStream fs = new FileStream(path, FileMode.Create))
				{
					fs.Write(idls.GetBuffer(), 0, (int)idls.Length);
				}
			}
		}
		
		static void EmitStubs(XmlNodeList xnl, string pat)
		{
			foreach (XmlNode xn in xnl)
			{
				XmlAttribute xa = xn.Attributes["name"];
				if (xa == null || xa.Value == "")
				{
					throw new InvalidDataException("interface elements must have a name attribute");
				}
				if (!idre.IsMatch(xa.Value))
				{
					throw new InvalidDataException("interface name " + xa.Value + " is not a proper identifier");
				}
				MemoryStream idls = new MemoryStream();
				MemoryStream stubs = new MemoryStream();
				EmitInterface(xn, new StreamWriter(idls), new StreamWriter(stubs));
				string path = pat.Replace("%", xa.Value);
				using (FileStream fs = new FileStream(path, FileMode.Create))
				{
					fs.Write(stubs.GetBuffer(), 0, (int)stubs.Length);
				}
			}
		}
		
		static void EmitEntities(XmlNodeList xnl, string pat)
		{
			foreach (XmlNode xn in xnl)
			{
				XmlAttribute xa = xn.Attributes["name"];
				if (xa == null || xa.Value == "")
				{
					throw new InvalidDataException("entity elements must have a name attribute");
				}
				if (!idre.IsMatch(xa.Value))
				{
					throw new InvalidDataException("entity name " + xa.Value + " is not a proper identifier");
				}
				MemoryStream ents = new MemoryStream();
				EmitEntity(xn, new StreamWriter(ents));
				string path = pat.Replace("%", xa.Value);
				using (FileStream fs = new FileStream(path, FileMode.Create))
				{
					fs.Write(ents.GetBuffer(), 0, (int)ents.Length);
				}
			}
		}
		
		public static void EmitInterface(XmlNode itf, StreamWriter idl, StreamWriter stub)
		{
			string iname = Helpers.AttributeStr(itf, "name");
			string iversion = Helpers.AttributeStr(itf, "version");
			idl.WriteLine("//  interface {0}", iname);
			idl.WriteLine("//  auto-generated by apimono");
			idl.WriteLine("");
			idl.WriteLine("using IMVU.IDL;");
			idl.WriteLine("using ApiParameter = IMVU.IDL.ApiMethod.ApiParameter;");
			idl.WriteLine("");
			idl.WriteLine("namespace idl");
			idl.WriteLine("{0}", "{");
			idl.WriteLine("");
			idl.WriteLine("public class {0} : WrapperBase {1}", iname, "{");
			idl.WriteLine("    public {0}() : base(\"{1}\") {2}", iname, iname, "{}");
			idl.WriteLine("    public override string Version() {0} return \"{1}\"; {2}",
			              "{", iversion, "}");
			idl.WriteLine("    public override void Initialize() {0}", "{");
			idl.WriteLine("        InstallMethods(new ApiMethod[] {0}", "{");
			
			stub.WriteLine("//  implementation of interface {0} version {1}", iname, iversion);
			stub.WriteLine("//  auto-generated by apimono");
			stub.WriteLine("");
			stub.WriteLine("using IMVU.IDL;");
			stub.WriteLine("using System;");
			stub.WriteLine("using System.Collections.Generic;");
			stub.WriteLine("using entity;");
			stub.WriteLine("");
			stub.WriteLine("namespace api");
			stub.WriteLine("{0}", "{");
			stub.WriteLine("");
			stub.WriteLine("public class {0} {1}", iname, "{");
			
			foreach (XmlNode xn in itf.SelectNodes("method"))
			{
				string mname = Helpers.AttributeStr(xn, "name");
				idl.WriteLine("    new ApiMethod(\"{0}\", \"{1}\", // name", iname, mname);
				bool mauth = Helpers.AttributeBool(xn, "session", true);
				string mtype = Helpers.AttributeStr(xn, "type", "dict");
				idl.WriteLine("        {0}, // session", mauth ? "true" : "false");
				idl.WriteLine("        new string[] {0} // permissions", "{");
				foreach (XmlNode pn in xn.SelectNodes("permission"))
				{
					string pname = Helpers.AttributeStr(pn, "name");
                    string self = Helpers.AttributeStr(pn, "self", "");
                    if (self.Length > 0)
                    {
                        if (null == xn.SelectSingleNode("parameter[@name='"+self+"']"))
                        {
                            throw new ArgumentException("permission self attribute references parameter " + 
                                self + " which is not declared (method " + mname + ")");
                        }
                        idl.WriteLine("            \"self={0}|{1}\",", self, pname);
                    }
                    else
                    {
                        idl.WriteLine("            \"{0}\",", pname);
                    }
				}
				idl.WriteLine("        {0},", "}");
				idl.WriteLine("        Services.{0}f, // formatter", Helpers.AttributeStr(xn, "formatter", "json"));
				idl.WriteLine("        new ApiParameter[] {0} // parameters", "{");
				
				stub.WriteLine("");
				stub.Write("    public {1} {0}(IContext ctx", mname, mtype);
				
				foreach (XmlNode an in xn.SelectNodes("parameter"))
				{
					string pname = Helpers.AttributeStr(an, "name");
					idl.WriteLine("            new ApiParameter(\"{0}\", // name", pname);
					string ptype = Helpers.AttributeStr(an, "type");
					idl.WriteLine("                Services.Types.t_{0} // type", ptype);
					idl.WriteLine("                ),");
					
					stub.Write(", {0} {1}", ptype, pname);
				}
				idl.WriteLine("            {0}), // ApiMethod", "}");
				
				stub.WriteLine(")");
				stub.WriteLine("    {0}", "{");
				stub.WriteLine("        dict Return = new {0}();", mtype);
				stub.WriteLine("        // your code goes here; add return values to 'Return'");
				if (mtype == "dict")
				{
					foreach (XmlNode rn in xn.SelectNodes("return"))
					{
						string rname = Helpers.AttributeStr(rn, "name");
						string rtype = Helpers.AttributeStr(rn, "type");
						stub.WriteLine("        Return.Add(\"{0}\", Helpers.Default<{1}>());", rname, rtype);
					}
				}
				else if (xn.SelectNodes("return").Count > 0)
				{
					throw new InvalidDataException("Method " + mname + " of type " + mtype + " cannot have a 'return' element.");
				}
				stub.WriteLine("        return Return;");
				stub.WriteLine("    {0} // {1}", "}", mname);
				stub.WriteLine("");
			}
			idl.WriteLine("            {0}); // InstallMethods", "}");
			idl.WriteLine("    {0}", "}");
			idl.WriteLine("{0}", "}");
			idl.WriteLine("");
			idl.WriteLine("{0} // namespace", "}");
			idl.WriteLine("");
			idl.WriteLine("//  end of {0}", iname);

			stub.WriteLine("{0}; // class", "}");
			stub.WriteLine("");
			stub.WriteLine("{0} // namespace", "}");
			stub.WriteLine("");
			stub.WriteLine("//  end of {0}", iname);
			
			idl.Flush();
			stub.Flush();
		}
		
		public static void EmitEntity(XmlNode itf, StreamWriter ent)
		{
			throw new NotImplementedException("EmitEntity() not implemented");
		}
	}
}
